import type { FileWithDiff } from './review-core.js';

export interface ContextCompressionOptions {
  enabled?: boolean;
  maxTokens?: number;
  thresholdPercent?: number;
  softBufferTokens?: number;
  hardBufferTokens?: number;
  tokenEstimateDivisor?: number;
}

/** Metadata about a file omitted due to token budget */
export interface OmittedFileInfo {
  filename: string;
  /** Number of added lines in the diff */
  additions: number;
  /** Number of deleted lines in the diff */
  deletions: number;
  /** Whether this is a newly created file */
  isNew: boolean;
  /** Estimated token count of the diff entry */
  estimatedTokens: number;
}

export interface ContextCompressionResult {
  files: FileWithDiff[];
  omitted: {
    deletionsOnly: string[];
    dueToBudget: OmittedFileInfo[];
    generated: string[];
  };
}

const DEFAULT_COMPRESSION_OPTIONS: Required<ContextCompressionOptions> = {
  enabled: true,
  maxTokens: 8000,
  thresholdPercent: 0,
  softBufferTokens: 1500,
  hardBufferTokens: 1000,
  tokenEstimateDivisor: 4,
};

function normalizeOptions(
  options?: ContextCompressionOptions
): Required<ContextCompressionOptions> {
  return {
    ...DEFAULT_COMPRESSION_OPTIONS,
    ...options,
  };
}

function estimateTokens(text: string, divisor: number): number {
  const normalizedDivisor =
    divisor > 0 ? divisor : DEFAULT_COMPRESSION_OPTIONS.tokenEstimateDivisor;
  return Math.ceil(text.length / normalizedDivisor);
}

function buildDiffEntry(file: FileWithDiff): string {
  return `### ${file.filename}\n\n\`\`\`diff\n${file.patch}\n\`\`\``;
}

/** Count additions, deletions, and detect new-file status from a unified diff patch */
export function computePatchStats(patch: string): {
  additions: number;
  deletions: number;
  isNew: boolean;
} {
  let additions = 0;
  let deletions = 0;
  let isNew = false;
  for (const line of patch.split('\n')) {
    if (line.startsWith('+') && !line.startsWith('+++')) {
      additions++;
    } else if (line.startsWith('-') && !line.startsWith('---')) {
      deletions++;
    } else if (line.startsWith('new file mode')) {
      isNew = true;
    }
  }
  return { additions, deletions, isNew };
}

export function stripDeletionOnlyHunks(patch: string): string {
  const lines = patch.split('\n');
  const preserved: string[] = [];
  const prefix: string[] = [];
  let currentHunk: string[] = [];
  let sawHunk = false;
  let hunkHasAddition = false;

  const flushHunk = () => {
    if (currentHunk.length > 0) {
      if (hunkHasAddition) {
        preserved.push(...currentHunk);
      }
      currentHunk = [];
      hunkHasAddition = false;
    }
  };

  for (const line of lines) {
    if (line.startsWith('@@')) {
      sawHunk = true;
      flushHunk();
      currentHunk.push(line);
      continue;
    }

    if (!sawHunk) {
      prefix.push(line);
      continue;
    }

    currentHunk.push(line);
    if (line.startsWith('+') && !line.startsWith('+++')) {
      hunkHasAddition = true;
    }
  }

  flushHunk();

  if (!sawHunk) {
    return patch.trim();
  }

  if (preserved.length === 0) {
    return '';
  }

  return [...prefix, ...preserved].join('\n').trim();
}

const GENERATED_MARKERS = [
  '@generated',
  'Code generated by',
  'auto-generated',
  'DO NOT EDIT',
  'This file is automatically generated',
];

export function filterGeneratedFiles(files: FileWithDiff[]): {
  kept: FileWithDiff[];
  generated: string[];
} {
  const kept: FileWithDiff[] = [];
  const generated: string[] = [];

  for (const file of files) {
    const patch = file.patch ?? '';
    if (GENERATED_MARKERS.some((marker) => patch.includes(marker))) {
      generated.push(file.filename);
    } else {
      kept.push(file);
    }
  }

  return { kept, generated };
}

export function compressFilesWithDiffs(
  files: FileWithDiff[],
  options?: ContextCompressionOptions
): ContextCompressionResult {
  const resolvedOptions = normalizeOptions(options);
  if (!resolvedOptions.enabled) {
    return {
      files,
      omitted: {
        deletionsOnly: [],
        dueToBudget: [],
        generated: [],
      },
    };
  }

  const deletionsOnly: string[] = [];
  const budgetOmitted: OmittedFileInfo[] = [];

  const filesWithDiffs: FileWithDiff[] = [];
  for (const file of files) {
    if (!file.patch) continue;
    const trimmedPatch = stripDeletionOnlyHunks(file.patch ?? '');
    if (!trimmedPatch.trim()) {
      deletionsOnly.push(file.filename);
      continue;
    }
    filesWithDiffs.push({
      filename: file.filename,
      patch: trimmedPatch,
    });
  }

  if (filesWithDiffs.length === 0) {
    return {
      files,
      omitted: {
        deletionsOnly,
        dueToBudget: [],
        generated: [],
      },
    };
  }

  const entries = filesWithDiffs.map((file) => {
    const entryText = buildDiffEntry(file);
    return {
      file,
      entryText,
      tokens: estimateTokens(entryText, resolvedOptions.tokenEstimateDivisor),
    };
  });

  const totalTokens = entries.reduce((sum, entry) => sum + entry.tokens, 0);
  const softLimit = resolvedOptions.maxTokens - resolvedOptions.softBufferTokens;
  const hardLimit = resolvedOptions.maxTokens - resolvedOptions.hardBufferTokens;

  if (totalTokens <= softLimit) {
    const patchLookup = new Map(filesWithDiffs.map((file) => [file.filename, file.patch]));
    return {
      files: files.map((file) =>
        file.patch ? { filename: file.filename, patch: patchLookup.get(file.filename) } : file
      ),
      omitted: {
        deletionsOnly,
        dueToBudget: [],
        generated: [],
      },
    };
  }

  const sorted = [...entries].sort((a, b) => {
    if (b.tokens !== a.tokens) return b.tokens - a.tokens;
    return a.file.filename.localeCompare(b.file.filename);
  });

  const kept: FileWithDiff[] = [];
  let currentTokens = 0;

  for (const entry of sorted) {
    if (currentTokens > hardLimit) {
      const stats = computePatchStats(entry.file.patch ?? '');
      budgetOmitted.push({
        filename: entry.file.filename,
        ...stats,
        estimatedTokens: entry.tokens,
      });
      continue;
    }

    if (currentTokens + entry.tokens > softLimit) {
      const stats = computePatchStats(entry.file.patch ?? '');
      budgetOmitted.push({
        filename: entry.file.filename,
        ...stats,
        estimatedTokens: entry.tokens,
      });
      continue;
    }

    kept.push(entry.file);
    currentTokens += entry.tokens;
  }

  const keptLookup = new Map(kept.map((entry) => [entry.filename, entry.patch]));
  const keptFiles = files.map((file) => {
    if (!file.patch) return file;
    const keptPatch = keptLookup.get(file.filename);
    return keptPatch ? { filename: file.filename, patch: keptPatch } : { filename: file.filename };
  });

  return {
    files: keptFiles,
    omitted: {
      deletionsOnly,
      dueToBudget: budgetOmitted,
      generated: [],
    },
  };
}

export function resolveCompressionBudget(
  contextWindow: number | undefined,
  options?: ContextCompressionOptions
): ContextCompressionOptions {
  if (!options) return {};

  const resolvedOptions = normalizeOptions(options);
  const threshold = resolvedOptions.thresholdPercent;

  if (threshold && threshold > 0 && contextWindow && contextWindow > 0) {
    const computedMaxTokens = Math.max(1, Math.floor(contextWindow * threshold));

    if (computedMaxTokens >= resolvedOptions.maxTokens) {
      return {
        ...resolvedOptions,
        maxTokens: computedMaxTokens,
      };
    }

    const scale = computedMaxTokens / resolvedOptions.maxTokens;
    const scaleBuffer = (value: number): number => Math.max(0, Math.floor(value * scale));

    return {
      ...resolvedOptions,
      maxTokens: computedMaxTokens,
      softBufferTokens: scaleBuffer(resolvedOptions.softBufferTokens),
      hardBufferTokens: scaleBuffer(resolvedOptions.hardBufferTokens),
    };
  }

  return options;
}

export function prepareDiffsForAgent(
  files: FileWithDiff[],
  options?: ContextCompressionOptions
): ContextCompressionResult {
  const { kept, generated } = filterGeneratedFiles(files);
  const result = compressFilesWithDiffs(kept, options);
  return {
    ...result,
    omitted: {
      ...result.omitted,
      generated,
    },
  };
}

export function formatCompressionSummary(result: ContextCompressionResult): string {
  const sections: string[] = [];

  if (result.omitted.generated.length > 0) {
    sections.push(
      `- Auto-excluded generated files (machine-generated, not reviewed):\n${result.omitted.generated
        .map((name) => `  - ${name}`)
        .join('\n')}`
    );
  }

  if (result.omitted.deletionsOnly.length > 0) {
    sections.push(
      `- Deletions-only changes (omitted from diff content):\n${result.omitted.deletionsOnly
        .map((name) => `  - ${name}`)
        .join('\n')}`
    );
  }

  if (result.omitted.dueToBudget.length > 0) {
    // Sort by additions descending so agents see highest-value files first
    const sorted = [...result.omitted.dueToBudget].sort((a, b) => b.additions - a.additions);
    sections.push(
      `- Omitted due to token budget (use Read/Grep tools to inspect, listed by review priority):\n${sorted
        .map((info) => {
          const parts = [`+${info.additions}`, `-${info.deletions}`];
          if (info.isNew) parts.push('new file');
          parts.push(`~${info.estimatedTokens} tokens`);
          return `  - ${info.filename} (${parts.join(', ')})`;
        })
        .join('\n')}`
    );
  }

  if (sections.length === 0) {
    return '';
  }

  return `## Omitted Files\n\n${sections.join('\n\n')}`;
}
