import chalk from 'chalk';
import type { PlatformClient } from './platform-client.js';

export type Platform = 'PR' | 'MR';

/**
 * Display description to console
 */
export function displayDescription(description: any, platform: Platform = 'PR') {
  console.log(chalk.bold.cyan(`ðŸ“ Generated ${platform} Description\n`));

  // Type
  console.log(chalk.bold('Type: ') + chalk.yellow(description.type));

  // Title
  console.log(chalk.bold('\nTitle:'));
  console.log(chalk.white(description.title));

  // Summary
  console.log(chalk.bold('\nSummary:'));
  for (const bullet of description.summary) {
    console.log(chalk.white(`  â€¢ ${bullet}`));
  }

  // Walkthrough
  if (description.walkthrough && description.walkthrough.length > 0) {
    console.log(chalk.bold('\nðŸ“‚ Changes Walkthrough:\n'));

    for (const fileChange of description.walkthrough) {
      const icon = getChangeIcon(fileChange.changeType);
      const significance = fileChange.significance === 'major' ? chalk.red('â­') : '';

      console.log(
        chalk.cyan(`${icon} ${fileChange.file} ${significance} (${fileChange.semanticLabel})`)
      );
      console.log(chalk.dim(`   ${fileChange.title}`));

      if (fileChange.changes && fileChange.changes.length > 0) {
        for (const change of fileChange.changes) {
          console.log(chalk.white(`     â€¢ ${change}`));
        }
      }
      console.log();
    }
  }

  // Labels
  if (description.labels && description.labels.length > 0) {
    console.log(chalk.bold('ðŸ·ï¸  Suggested Labels:'));
    console.log(chalk.white('  ' + description.labels.join(', ')));
  }

  // Recommendations
  if (description.recommendations && description.recommendations.length > 0) {
    console.log(chalk.bold('\nðŸ’¡ Recommendations:\n'));
    for (const rec of description.recommendations) {
      console.log(chalk.yellow(`  â€¢ ${rec}`));
    }
  }
}

/**
 * Get colored terminal icon for change type
 */
export function getChangeIcon(changeType: string): string {
  switch (changeType) {
    case 'added':
      return chalk.green('+');
    case 'modified':
      return chalk.yellow('~');
    case 'deleted':
      return chalk.red('-');
    case 'renamed':
      return chalk.blue('â†’');
    default:
      return chalk.gray('â€¢');
  }
}

/**
 * Get markdown emoji icon for change type
 */
export function getMarkdownChangeIcon(changeType: string): string {
  switch (changeType) {
    case 'added':
      return 'âž•';
    case 'modified':
      return 'âœï¸';
    case 'deleted':
      return 'âž–';
    case 'renamed':
      return 'âž¡ï¸';
    default:
      return 'ðŸ“„';
  }
}

/**
 * Format description as markdown
 */
export function formatDescriptionAsMarkdown(description: any, platform: Platform = 'PR'): string {
  let markdown = `## AI-Generated ${platform} Description\n\n`;

  markdown += `**Type:** ${description.type}\n\n`;

  markdown += '### Summary\n\n';
  for (const bullet of description.summary) {
    markdown += `- ${bullet}\n`;
  }

  if (description.walkthrough && description.walkthrough.length > 0) {
    markdown += '\n### Changes Walkthrough\n\n';
    markdown += '<details>\n<summary>View file-by-file changes</summary>\n\n';

    for (const fileChange of description.walkthrough) {
      const icon = getMarkdownChangeIcon(fileChange.changeType);
      markdown += `#### ${icon} \`${fileChange.file}\` (${fileChange.semanticLabel})\n\n`;
      markdown += `**${fileChange.title}**\n\n`;

      if (fileChange.changes && fileChange.changes.length > 0) {
        for (const change of fileChange.changes) {
          markdown += `- ${change}\n`;
        }
        markdown += '\n';
      }
    }

    markdown += '</details>\n\n';
  }

  if (description.labels && description.labels.length > 0) {
    markdown += '### Suggested Labels\n\n';
    markdown += description.labels.map((l: string) => `\`${l}\``).join(', ') + '\n\n';
  }

  if (description.recommendations && description.recommendations.length > 0) {
    markdown += '### Recommendations\n\n';
    for (const rec of description.recommendations) {
      markdown += `- ${rec}\n`;
    }
    markdown += '\n';
  }

  markdown += '\n---\n*Generated by DRS - Diff Review System*\n';

  return markdown;
}

/**
 * Post description to PR/MR as comment
 */
export async function postDescription(
  platformAdapter: PlatformClient,
  projectId: string,
  prNumber: number,
  description: any,
  platform: Platform = 'PR'
) {
  console.log(chalk.dim(`\nPosting description to ${platform}...`));

  const markdown = formatDescriptionAsMarkdown(description, platform);
  await platformAdapter.createComment(projectId, prNumber, markdown);

  console.log(chalk.green(`âœ“ Description posted to ${platform}`));
}
